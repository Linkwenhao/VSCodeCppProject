## 对取余运算的说明

**取余，也就是求余数，使用的运算符是 %**。C语言中的取余运算只能针对整数，**也就是说，% 的两边都必须是整数，不能出现小数，否则编译器会报错**。

另外，余数可以是正数也可以是负数，由 % 左边的整数决定：

- **如果 % 左边是正数，那么余数也是正数；**
- **如果 % 左边是负数，那么余数也是负数。**

## 解题思路

### 初步思路：

<img src="https://pic.leetcode-cn.com/be35cb60bec9a9ae794abad671e6618abb5664780bc7ee30ca93ca423884a666-1.jpg" style="zoom: 67%;" />

1、将12345 % 10 得到5，之后将12345 / 10 =1234
2、将1234 % 10 得到4，再将1234 / 10 =123
3、将123 % 10 得到3，再将123 / 10 =12
4、将12 % 10 得到2，再将12 / 10 = 1
5、将1 % 10 得到1，再将1 / 10 = 0

这么看起来，一个循环就搞定了，循环的判断条件是x>0  ，**但这样不对，因为忽略了负数**

**循环的判断条件应该是`while(x!=0)`**，无论正数还是负数，按照上面不断的/10这样的操作，最后都会变成0，所以判断终止条件就是!=0

有了取模和除法操作，对于像12300这样的数字，也可以完美的解决掉了。

### 题目要求：

> **假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31,  2^31 − 1]**  --> [-2147483648, 2147483647]

**也就是说我们不能用long存储最终结果，而且有些数字可能是合法范围内的数字，但是反转过来就超过范围了。**

**假设有1147483649这个数字，它是小于最大的32位整数2147483647的，但是将这个数字反转过来后就变成了9463847411**

这就比最大的32位整数还要大了，这样的数字是没法存到`int`里面的，所以肯定要返回0**(溢出了)**。

### 因此

<u>**如果反转后整数超过 32 位的有符号整数的范围 [$$−2^{31}$$,  $$2^{31}$$ − 1] ，就返回 0。**</u> **注意是指翻转后！！！！！！**
$$
\textit{INT\_MIN}=-2^{31}=-2147483648
$$

$$
\textit{INT\_MAX}=2^{31}-1=2147483647
$$

$$
−2^{31}≤rev⋅10+digit≤2^{31}
$$

若该不等式不成立则返回 0。

**对于正数，推入数字前判断**：

要满足以下不等式:
$$
(rev-[\frac{\textit{INT\_MAX}}{10}])*10<=7-digit
$$
即当且仅当：
$$
rev<=[\frac{\textit{INT\_MAX}}{10}]
$$
上述不等式成立。

**对于负数也是一样的:**

最终得到判断不等式
$$
[\frac{-2^{31}}{10}]<=rev<=[\frac{2^{31}-1}{10}]
$$

