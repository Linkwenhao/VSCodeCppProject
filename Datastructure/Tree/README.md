## 树

之前介绍的所有的[数据结构](http://c.biancheng.net/data_structure/)都是[线性存储结构](http://c.biancheng.net/view/3333.html)。本章所介绍的树结构是一种非线性存储结构，存储的是具有“一对多”关系的数据元素的集合。

![](http://c.biancheng.net/uploads/allimg/190427/0944301493-0.png)

对于一个结点，拥有的子树数（结点有多少分支）称为结点的度（Degree）。例如，图 1（A）中，根结点 A 下分出了 3 个子树，所以，结点 A 的度为 3。



**一棵树的度是树内各结点的度的最大值。图 1（A）表示的树中，各个结点的度的最大值为 3，所以，整棵树的度的值是 3。**



结点的层次：**从一棵树的树根开始，树根所在层为第一层，根的孩子结点所在的层为第二层，依次类推。对于图 1（A）来说，A 结点在第一层，B、C、D 为第二层，E、F、G、H、I、J 在第三层，K、L、M 在第四层。**

**一棵树的深度（高度）是树中结点所在的最大的层次。图 1（A）树的深度为 4。**

## 森林

**由 m（m >= 0）个互不相交的树组成的集合被称为森林**。图 1（A）中，分别以 B、C、D 为根结点的三棵子树就可以称为森林。

前面讲到，树可以理解为是由根结点和若干子树构成的，而这若干子树本身是一个森林，所以，树还可以理解为是由根结点和森林组成的。用一个式子表示为：



## 二叉树的性质

经过前人的总结，二叉树具有以下几个性质：

![](http://c.biancheng.net/uploads/allimg/190427/09452LR1-0.gif)

1. 二叉树中，第 `i` 层最多有 $$2^{i-1}$$个结点。

2. 如果二叉树的深度为 K，那么此二叉树最多有 $$2^{K}-1$$ 个结点。

3. 二叉树中，终端结点数（叶子结点数）为 $$n_0$$，度为 2 的结点数为 $$n_2$$，则 $$n_0=n_2+1$$。

   性质 3 的计算方法为：对于一个二叉树来说，除了度为 0 的叶子结点和度为 2 的结点，剩下的就是度为 1 的结点（设为 $$n_1$$），那么总结点 $$n=n_0+n_1+n_2$$。

   同时，对于每一个结点来说都是由其父结点分支表示的，假设树中分枝数为 B，那么总结点数 $$n=B+1$$。而分枝数是可以通过 n1 和 n2 表示的，即 $$B=n_1+2*n_2$$。所以，n 用另外一种方式表示为 $$n=n_1+2*n_2+1$$

   两种方式得到的 n 值组成一个方程组，就可以得出 $$n_0=n_2+1$$。

## 满二叉树

![](http://c.biancheng.net/uploads/allimg/190427/09452HG8-1.gif)

1. 满二叉树中第 `i` 层的节点数为 $$2^{n-1}$$ 个。
2. 深度为 k 的满二叉树必有 $$2^{k}-1$$ 个节点 ，叶子数为 $$2^{k-1}$$。
3. 满二叉树中不存在度为 1 的节点，每一个分支点中都两棵深度相同的子树，且叶子节点都在最底层。
4. 具有 n 个节点的满二叉树的深度为 $$log_2(n+1)$$。

## 完全二叉树

如果二叉树中除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布，则此二叉树被称为完全二叉树。

![](http://c.biancheng.net/uploads/allimg/190427/09452Mb5-2.gif)

完全二叉树除了具有普通二叉树的性质，它自身也具有一些独特的性质，比如说，n 个结点的完全二叉树的深度为 $$[log_2n]+1$$

$$[log_2n]$$ 表示取小于 $$log_2n$$ 的最大整数。例如，$$[log_24] = 2$$，而 $$[log_25]$$ 结果也是 2。

**对于任意一个完全二叉树来说，如果将含有的结点按照层次从左到右依次标号（如图 3a)），对于任意一个结点 `i` ，完全二叉树还有以下几个结论成立：**

1. 当 `i`>1 时，父亲结点为结点 `[i/2]` 。（`i`=1 时，表示的是根结点，无父亲结点）
2. 如果 `2*i`>n（总结点的个数） ，则结点` i` 肯定没有左孩子（为叶子结点）；否则其左孩子是结点 `2*i` 。
3. 如果 `2*i`+1>n ，则结点 `i` 肯定没有右孩子；否则右孩子是结点 `2*i`+1 。

# 顺序存储结构

二叉树的顺序存储，指的是使用[顺序表](http://c.biancheng.net/view/3334.html)（数组）存储二叉树。需要注意的是，`顺序存储只适用于完全二叉树`。换句话说，**只有完全二叉树才可以使用顺序表存储**。

因此，如果我们想顺序存储普通二叉树，需要提前将普通二叉树转化为完全二叉树。



普通二叉树转完全二叉树的方法很简单，只需给二叉树额外添加一些节点，将其"拼凑"成完全二叉树即可。如图 1 所示：

![](http://c.biancheng.net/uploads/allimg/190427/094624M02-0.png)

图 1 中，左侧是普通二叉树，右侧是转化后的完全（满）二叉树。

解决了二叉树的转化问题，接下来学习如何顺序存储完全（满）二叉树。

**完全二叉树的顺序存储，仅需从根节点开始，按照层次依次将树中节点存储到数组即可。**

![](http://c.biancheng.net/uploads/allimg/190427/0946243158-1.gif)



例如，存储图 2 所示的完全二叉树，其存储状态如图 3 所示：

![image-20211224105329105](C:\Users\linwenhao\AppData\Roaming\Typora\typora-user-images\image-20211224105329105.png)

同样，存储由普通二叉树转化来的完全二叉树也是如此。例如，图 1 中普通二叉树的数组存储状态如图 4 所示：

![1](http://c.biancheng.net/uploads/allimg/190427/094624F04-3.png)



## 链式

上一节讲了[二叉树](http://c.biancheng.net/view/3384.html)的顺序存储，通过学习你会发现，其实二叉树并不适合用数组存储，因为并不是每个二叉树都是完全二叉树，普通二叉树使用[顺序表](http://c.biancheng.net/view/3334.html)存储或多或多会存在空间浪费的现象。

![](http://c.biancheng.net/uploads/allimg/190427/094GJ2Z-1.gif)

由图 2 可知，采用链式存储二叉树时，其节点结构由 3 部分构成（如图 3 所示）：

- 指向左孩子节点的指针（`Lchild`）；

- 节点存储的数据（data）；

- 指向右孩子节点的指针（`Rchild`）；

  ![](http://c.biancheng.net/uploads/allimg/190427/094GK034-2.gif)





## 遍历二叉树的算法（$$O(logN)$$）

![](http://c.biancheng.net/uploads/allimg/190427/094P32K3-0.gif)

#### 层次遍历

**前面讲过，树是有层次的，拿图 1 来说，该二叉树的层次为 3。通过对树中各层的节点从左到右依次遍历，即可实现对正棵二叉树的遍历，此种方式称为层次遍历。**

![](http://c.biancheng.net/uploads/allimg/190427/094P3CK-1.gif)

#### 普通遍历

其实，还有一种更普通的遍历二叉树的思想，即按照 "从上到下，从左到右" 的顺序遍历整棵二叉树。

还拿图 1 中的二叉树举例，其遍历过程如图 3 所示：

![](http://c.biancheng.net/uploads/allimg/190427/094P344W-2.gif)

通过观察图 3 可以看到，整个遍历二叉树的过程中，每个节点都被经过了 3 次（虽然叶子节点看似只经过了 2 次，但实际上可以看做是 3 次）。以图 3 中的节点 2 为例，如图 4 所示，它被经过了 3 次。

![](http://c.biancheng.net/uploads/allimg/190427/094P36220-3.gif)

**因此，在编程实现时，我们可以设定真正访问各个节点的时机，换句话说，我们既可以在第一次经过各节点时就执行访问程序，也可以在第二次经过各节点时访问，甚至可以在最后一次经过各节点时访问。**

这也就引出了以下 3 种遍历二叉树的算法：

1. 先序遍历：每遇到一个节点，先访问，然后再遍历其左右子树（对应图 4 中的 ①）；
2. 中序遍历：第一次经过时不访问，等遍历完左子树之后再访问，然后遍历右子树（对应图 4 中的 ②）；
3. 后序遍历：第一次和第二次经过时都不访问，等遍历完该节点的左右子树之后，最后访问该节点（对应图 4 中的 ③）；

以图 1 中的二叉树为例，其先序遍历算法访问节点的先后次序为 

> 1 2 4 5 3 6 7    根节点在前

中序遍历算法访问节点的次序为：

> 4 2 5 1 6 3 7    根节点在中

后序遍历访问节点的次序为：

> 4 5 2 6 7 3 1    根节点在后

以上就是二叉树 4 种遍历算法的由来，其各个算法的具体实现过程其代码实现后续章节会详解介绍。



## Huffman

![](http://c.biancheng.net/uploads/allimg/190427/09563Tb0-0.png)



路径：**在一棵树中，一个结点到另一个结点之间的通路，称为路径**。图 1 中，从根结点到结点 a 之间的通路就是一条路径。

路径长度：在一条路径中，每经过一个结点，路径长度都要加 1 。例如在一棵树中，规定根结点所在层数为1层，那么从根结点到第` i `层结点的路径长度为 `i `- 1 。图 1 中从根结点到结点 c 的路径长度为 3。

结点的权：给每一个结点赋予一个新的数值，被称为这个结点的权。例如，图 1 中结点 a 的权为 7，结点 b 的权为 5。

结点的带权路径长度：指的是从根结点到该**结点之间的路径长度与该结点的权的乘积**。例如，图 1 中结点 b 的带权路径长度为 2 * 5 = 10 。

## 什么是哈夫曼树

当用 n 个结点（都做叶子结点且都有各自的权值）试图构建一棵树时，**如果构建的这棵树的带权路径长度最小，称这棵树为“最优二叉树”**，有时也叫“赫夫曼树”或者“哈夫曼树”。



`**在构建哈弗曼树时，要使树的带权路径长度最小，只需要遵循一个原则，那就是：权重越大的结点离树根越近。在图 1 中，因为结点 a 的权值最大，所以理应直接作为根结点的孩子结点。**



对于给定的有各自权值的 n 个结点，构建哈夫曼树有一个行之有效的办法：

1. 在 n 个权值中选出两个最小的权值，对应的两个结点组成一个新的二叉树，且新二叉树的根结点的权值为左右孩子权值的和；
2. 在原有的 n 个权值中删除那两个最小的权值，同时将新的权值加入到 n–2 个权值的行列中，以此类推；
3. 重复 1 和 2 ，直到所以的结点构建成了一棵二叉树为止，这棵树就是哈夫曼树。

![](http://c.biancheng.net/uploads/allimg/190427/09563QS5-1.png)

图 2 中，（A）给定了四个结点a，b，c，d，权值分别为7，5，2，4；第一步如（B）所示，找出现有权值中最小的两个，2 和 4 ，相应的结点 c 和 d 构建一个新的二叉树，树根的权值为 2 + 4 = 6，同时将原有权值中的 2 和 4 删掉，将新的权值 6 加入；进入（C），重复之前的步骤。直到（D）中，所有的结点构建成了一个全新的二叉树，这就是哈夫曼树。

## 哈弗曼树中结点结构

构建哈夫曼树时，首先需要确定树中结点的构成。由于哈夫曼树的构建是从叶子结点开始，不断地构建新的父结点，直至树根，所以结点中应包含指向父结点的指针。但是在使用哈夫曼树时是从树根开始，根据需求遍历树中的结点，因此每个结点需要有指向其左孩子和右孩子的指针。

```cpp
//哈夫曼树结点结构
typedef struct {
    int weight;//结点权重
    int parent, left, right;//父结点、左孩子、右孩子在数组中的位置下标
}HTNode, *HuffmanTree;
```

## 哈夫曼编码

根据发送信息的内容，通过统计文本中相同字符的个数作为每个字符的权值，建立哈夫曼树。**对于树中的每一个子树，统一规定其左孩子标记为 0 ，右孩子标记为 1** 。这样，用到哪个字符时，从哈夫曼树的根结点开始，依次写出经过结点的标记，最终得到的就是该结点的哈夫曼编码。

文本中字符出现的次数越多，在哈夫曼树中的体现就是越接近树根。编码的长度越短。

![](http://c.biancheng.net/uploads/allimg/190427/095H15110-0.png)



举个例子，如图 1 所示，这是用权值分别为 7、5、2、4 的字符 a、b、c、d 构建的哈夫曼树。显然，字符 a 用到的次数最多，所以它对应的哈弗曼编码应最短，这里用 `0` 表示；其次，是字符 b 用的多，因此字符 b 编码为 `10` ，以此类推，字符 c 的编码为 `110` ，字符 d 的编码为 `111`。

**权值越大，表示此字符在文件中出现的次数越多，那么，为了实现用最少的字符包含最多的内容，就应该给出现次数越多的字符，分配的哈弗曼编码越短。**



